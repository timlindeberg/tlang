package kool.std

import <Option>
import <Map>
import <MapEntry>
import <Iterator>

class HashMap<K, V>: Map<K, V> {

	var static DefualtInitialCapacity = 16
	var static DefaultLoadFactor = 0.75

	var entries: Option<Entry<K, V>>[]
	var size: Int
	var loadFactor: Double
	var capacity: Int

	Def new()                                         = init(DefualtInitialCapacity, DefaultLoadFactor)
	Def new(initialCapacity: Int)                     = init(initialCapacity, DefaultLoadFactor)
	Def new(initialCapacity: Int, loadFactor: Double) = init(initialCapacity, loadFactor)
	Def new(map: Map<K, V>) = {
		init(DefualtInitialCapacity, DefaultLoadFactor)
		AddAll(map)
	}

    Def Add(key: K, value: V) = {
        if(size >= loadFactor * capacity)
            resize()

        val hash = #key
        val newEntry = new Entry<K, V>(key, value, hash)

        if(addTo(entries, index(hash, capacity), newEntry))
            size++
    }

	Def Get(key: K) = {
		val maybeEntry = entries[index(#key, capacity)]
		if(!maybeEntry.IsDefined())
			return new Option<V>()

		val it = maybeEntry.Get().Iterator()
		while(it.HasNext()){
			val e = it.Next()
			if(e.Key() == key)
				return new Option<V>(e.Value())
		}
		new Option<V>()
	}

	Def Remove(key: K): Bool = {
		val index = index(#key, capacity)
		val maybeEntry = entries[index]

		if(!maybeEntry.IsDefined())
			return false

		val it = maybeEntry.Get().Iterator()
		var entry: Entry<K, V>
		var previous = new Option<Entry<K, V>>()
		while(it.HasNext()){
			entry = it.Next()
			if(entry.Key() != key){
                previous = new Option<Entry<K, V>>(entry)
                continue
			}

            if(!previous.IsDefined())
                entries[index] = new Option<Entry<K, V>>()
            else if(it.HasNext())
                previous.Get().Next = new Option<Entry<K, V>>(it.Next())
            else
                previous.Get().Next = new Option<Entry<K, V>>()

            size--
            return true
		}
	}

    Def Size() = size
	Def Capacity() = capacity
	Def Clear() = {
		entries = getNewDataContainer(capacity)
		size = 0
	}

	Def Iterator(): Iterator<MapEntry<K, V>> = new EntryIterator<K, V>(entries, this)
	Def KeyIterator(): Iterator<K>           = new KeyIterator<K, V>(entries, this)
	Def ValueIterator(): Iterator<V>         = new ValueIterator<K, V>(entries, this)

	def init(initialCapacity: Int, loadFactor: Double) = {
		capacity = (initialCapacity % 2 == 0) ? initialCapacity : closestPowerOfTwo(initialCapacity)
		this.loadFactor = loadFactor
		Clear()
	}

	def getNewDataContainer(capacity: Int) = {
		val data = new Option<Entry<K, V>>[capacity]
		for(var i = 0; i < capacity; i++)
			data[i] = new Option<Entry<K, V>>()
		data
	}

	def addTo(data: Option<Entry<K, V>>[], index: Int, newEntry: Entry<K, V>) = {
		val maybeEntry = data[index]

		if(!maybeEntry.IsDefined()){
		    data[index] = new Option<Entry<K, V>>(newEntry)
			return true
		}

		val it = maybeEntry.Get().Iterator()
		var entry: Entry<K, V>
		while(it.HasNext()){
			entry = it.Next()
			if(entry.Key() == newEntry.Key()){
				entry.SetValue(newEntry.Value())
				return false
			}
		}
		entry.Next = new Option<Entry<K, V>>(newEntry)
		true
	}

	def resize() = {
		val newCapacity = capacity << 1
		val newData = getNewDataContainer(newCapacity)

		for(var i = 0; i < capacity; i++){
		    if(!entries[i].IsDefined())
		        continue

            val it = entries[i].Get().Iterator()
            while(it.HasNext()){
                val entry = it.Next()
                entry.Next = new Option<Entry<K, V>>()
                addTo(newData, index(entry.Hash, newCapacity), entry)
            }
		}
		entries = newData
		capacity = newCapacity
	}

	def closestPowerOfTwo(value: Int) =
		for(var i = 2; ; i <<= 1)
			if(i >= value)
			   return i

	def index(hashCode: Int, capacity: Int) = improvedHash(hashCode) & capacity - 1

	def improvedHash(hash: Int) = {
	    var h = hash
		h ^= (h >> 20) ^ (h >> 12)
        h ^ (h >> 7) ^ (h >> 4)
	}
}

class Entry<K, V>: MapEntry<K, V>, Iterable<Entry<K, V>> {

	var key: K
	var value: V
	Var Hash: Int
	Var Next: Option<Entry<K, V>>

	Def new(key: K, value: V) 			 = init(key, value, 0)
	Def new(key: K, value: V, hash: Int) = init(key, value, hash)

    Def Key() = key
    Def Value() = value

    Def SetKey(key: K) = (this.key = key)
    Def SetValue(value: V) = (this.value = value)

	Def Iterator(): Iterator<Entry<K, V>> = new EntryListIterator<K, V>(this)

    Def ==(lhs: Entry<K, V>, rhs: Entry<K, V>) =
		lhs.key == rhs.key &&
	    lhs.value == rhs.value

	def init(key: K, value: V, hash: Int) = {
		this.key = key
		this.value = value
		Hash = hash
		Next = new Option<Entry<K, V>>()
	}

}

class EntryListIterator<K, V>: Iterator<Entry<K, V>> {

	var hasNext: Bool
	var current: Entry<K, V>

	Def new(startEntry: Entry<K, V>) = {
		hasNext = true
		current = startEntry
	}

	Def HasNext() = hasNext

	Def Next() = {
		val res = current
		hasNext = current.Next.IsDefined()
		if(hasNext)
			current = current.Next.Get()
		res
	}
}

class KeyIterator<K, V>: Iterator<K> {

	var it: EntryIterator<K, V>

	Def new(entries: Option<Entry<K, V>>[], map: HashMap<K, V>) =
		it = new EntryIterator<K, V>(entries, map)

	Def HasNext() = it.HasNext()

	Def Next() = it.Next().Key()

}

class ValueIterator<K, V>: Iterator<V> {

	var it: EntryIterator<K, V>

	Def new(entries: Option<Entry<K, V>>[], map: HashMap<K, V>) =
		it = new EntryIterator<K, V>(entries, map)

	Def HasNext() = it.HasNext()

	Def Next() = it.Next().Value()

}

class EntryIterator<K, V>: Iterator<MapEntry<K, V>> {

	var hasNext: Bool
	var currentEntry: Option<Entry<K, V>>
	var currentIndex: Int
	var entries: Option<Entry<K, V>>[]
	var map: HashMap<K, V>

	Def new(entries: Option<Entry<K, V>>[], map: HashMap<K, V>) = {
		this.map = map
		this.entries = entries
		hasNext = map.NonEmpty()
		currentEntry = nextDefinedEntry()
	}

	Def HasNext() = hasNext

	Def Next() = {
		val res = currentEntry.Get()
		currentEntry = nextEntry()
		hasNext = currentEntry.IsDefined()
		return res
	}

	def nextEntry() = {
		if(currentEntry.IsDefined() && currentEntry.Get().Next.IsDefined())
			return currentEntry.Get().Next

		nextDefinedEntry()
	}

	def nextDefinedEntry() = {
		for(; currentIndex < map.Capacity(); currentIndex++){
		    if(!entries[currentIndex].IsDefined())
		        continue

            val res = entries[currentIndex]
            currentIndex++
            return res
		}

		new Option<Entry<K, V>>()
	}


}