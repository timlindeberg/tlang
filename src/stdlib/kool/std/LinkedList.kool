package kool::std

import kool::std::Option
import kool::std::List
import kool::std::Collection

class LinkedList<T> : List<T> {

	var first = new Option<LinkedListNode<T>>()
	var last  = new Option<LinkedListNode<T>>()

	var size = 0

	Def new() = {}

	Def new(size: Int, value: T) =
        for(var i = 0; i < size; i++)
        	Add(value)

	Def new(elements: Collection<T>) = AddAll(elements)

	Def implicit new(elements: T[]) = {
		Clear()
		for(val e in elements)
			Add(e)
	}

    Def Get(index: Int) = {
        checkBounds(index)
    	find(index).Value
    }

    Def Set(index: Int, value: T) = {
        checkBounds(index)
    	find(index).Value = value
    }

	Def Size() = size

	Def Clear() = {
		first = new Option<LinkedListNode<T>>()
        last = new Option<LinkedListNode<T>>()
        size = 0
	}

	Def Iterator(): Iterator<T> = new LinkedListIterator<T>(first)

	Def Add(index: Int, value: T) = {
		if(index != size)
			checkBounds(index)

        val elem = new LinkedListNode<T>(value)
        val elemOp = new Option<LinkedListNode<T>>(elem)
        if(size == 0){
            // Empty list
            first = elemOp
            last = first
        } else if(index == size) {
            // Insert at end of the list
            elem.Prev = last
            last.Get().Next = elemOp
            last = elemOp
        } else if(index == 0) {
            // Insert at beginning of the list
            elem.Next = first
            first.Get().Prev = elemOp
            first = elemOp
        } else {
            // Insert in the middle of the list
            val node = find(index)
            val prev = node.Prev.Get()

            elem.Prev = new Option<LinkedListNode<T>>(prev)
            elem.Next = new Option<LinkedListNode<T>>(node)

            prev.Next = elemOp
            node.Prev = elemOp
        }
        size++
	}

	Def AddAll(index: Int, elements: Collection<T>) = {
	    if(elements.IsEmpty())
	        return

        checkBounds(index)

        var node = find(index)
        val post = node.Next
		for(val e in elements){
		    val n = new LinkedListNode<T>(e)
		    n.Prev = new Option<LinkedListNode<T>>(node)
		    node.Next = new Option<LinkedListNode<T>>(n)
		    node = n
		}
		if(post.IsDefined())
		    node.Next = post
	}

	Def RemoveIndex(index: Int) =  {
		checkBounds(index)

		val node = find(index)
        val prev = node.Prev
        val next = node.Next
        if(prev.IsDefined() && next.IsDefined()) {
            // LinkedListNode is in the middle of the list
            prev.Get().Next = next
            next.Get().Prev = prev
        } else if(prev.IsDefined() && !next.IsDefined()) {
            // LinkedListNode is last element
            prev.Get().Next = new Option<LinkedListNode<T>>()
            last = prev
        } else if(!prev.IsDefined() && next.IsDefined()) {
            // LinkedListNode is first element
            next.Get().Prev = new Option<LinkedListNode<T>>()
            first = next
        } else {
            // LinkedListNode is the only element
            Clear()
            size = 1
        }
        size--
	}

	Def FirstNode() = first
	Def LastNode() = last

	def find(index: Int) = {
        var tmp: Option<LinkedListNode<T>>
		if(index < (size / 2) + 1){
			tmp = first
			for(var i = 0; i < index; i++)
				tmp = tmp.Get().Next
		} else {
			tmp = last
			for(var i = size - 1; i > index; i--)
				tmp = tmp.Get().Prev
		}

		tmp.Get()
	}

	def checkBounds(index: Int) =
		if(index < 0 || index >= size)
			outOfBoundsError(index)

	def outOfBoundsError(index: Int) = error("Index out of bounds: " + index + " (size: " + size + ")")
}

class LinkedListNode<T> {

	Var Value: T
	Var Next: Option<LinkedListNode<T>> = new Option<LinkedListNode<T>>()
	Var Prev: Option<LinkedListNode<T>> = new Option<LinkedListNode<T>>()

	Def new(v: T) = Value = v
}

class LinkedListIterator<T> : Iterator<T> {
	var current: LinkedListNode<T>
	var hasNext: Bool

	Def new(first: Option<LinkedListNode<T>>) = {
		hasNext = first.IsDefined()
		if(hasNext)
			current = first.Get()
	}

	Def HasNext() = hasNext

	Def Next() = {
		val res =  current.Value

		hasNext = current.Next.IsDefined()
		if(hasNext)
			current = current.Next.Get()
		res
	}
}