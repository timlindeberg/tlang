package kool.std

import <Option>

class LinkedList<T> {
	var first: Option<Node<T>> = new Option<Node<T>>()
	var last:  Option<Node<T>> = new Option<Node<T>>()

	var size: Int = 0

	Def new() = { }

	Def new(size: Int, value: T) = {
		var i: Int = 0
        for(i = 0; i < size; i++)
        	Push(value)
	}

	Def new(list: LinkedList<T>) = {
		AddAll(list)
	}

	Def [](index: Int): Option<T> = {
		var res:  Option<T>       = new Option<T>()
		var node: Option<Node<T>> = find(index)

		if(node.IsDefined()){
			res.Add(node.Value().Value)
		}
		return res
	}

	Def []=(index: Int, value: T): Unit = {
		var node: Option<Node<T>> = find(index)

		if(node.IsDefined())
			node.Value().Value = value
	}

	Def ==(lhs: LinkedList<T>, rhs: LinkedList<T>): Bool = {
		var lhsIt:  LinkedListIterator<T>
		var rhsIt:  LinkedListIterator<T>

		if(lhs.size != rhs.size)
			return false

		lhsIt = lhs.Iterator()
		rhsIt = rhs.Iterator()
		while(lhsIt.HasNext()){
			if(lhsIt.Next() != rhsIt.Next())
				return false
		}

		return true
	}

	Def +(lhs: LinkedList<T>, rhs: T): LinkedList<T> = {
		lhs.Push(rhs)
		return lhs
	}

	Def +(lhs: LinkedList<T>, rhs: LinkedList<T>): LinkedList<T> = {
		lhs.AddAll(rhs)
		return lhs
	}

	Def -(lhs: LinkedList<T>, rhs: T): LinkedList<T> = {
		lhs.Remove(rhs)
		return lhs
	}

    Def NonEmpty(): Bool = {
        return size != 0
    }

	Def IsEmpty(): Bool = {
		return size == 0
	}

	Def Clear(): Unit = {
		first = new Option<Node<T>>()
        last = new Option<Node<T>>()
        size = 0
	}

	Def Iterator(): LinkedListIterator<T> = {
		return new LinkedListIterator<T>(this)
	}

	Def Push(value: T): Unit = {
		var node: Node<T> = new Node<T>(value)

		if(!first.IsDefined()){
			first.Add(node)
			last = first
		}else{
			node.SetPrev(last.Value())
			last.Value().SetNext(node)
			last = last.Value().Next()
		}
		size++
	}

	Def Pop(): Option<T> = {
		var res: Option<T> = new Option<T>()

		if(size <= 0)
		    return res

		res.Add(last.Value().Value)
		RemoveIndex(size - 1)
		return res
	}

	Def Add(value: T): Unit = {
	    Add(0, value)
	}

	Def Add(index: Int, value: T): Bool = {
		var node: Option<Node<T>>
		var next: Option<Node<T>>
		var prev: Option<Node<T>>
		var op:	  Option<Node<T>>
		var elem: Node<T>
		var res:  Bool

        if(index < 0 || index > size)
            return false

        elem = new Node<T>(value)
        if(index == size){
            Push(value)
        }else if(index == 0){
            first.Value().SetPrev(elem)
            elem.SetNext(first.Value())
            op = new Option<Node<T>>(elem)
            first = op
        }else{
            node = find(index)
            prev = node.Value().Prev()
            next = node.Value().Next()

            prev.Value().SetNext(elem)
            elem.SetPrev(prev.Value())

            elem.SetNext(node.Value())
            node.Value().SetPrev(elem)
        }
        size++

		return true
	}

    Def AddAll(list: LinkedList<T>): Unit = {
    	var it: LinkedListIterator<T> = list.Iterator()
    	while(it.HasNext())
    		Push(it.Next())
    }

	Def AddAll(index: Int, list: LinkedList<T>): Bool = {
		var it: LinkedListIterator<T> = list.Iterator()

		while(it.HasNext()){
			if(!Add(index, it.Next()))
			    return false
		}

		return true
	}

	Def Remove(value: T): Bool = {
		var index: Int = IndexOf(value)
		if(index != -1)
			return RemoveIndex(index)

		return false
	}

	Def RemoveIndex(index: Int): Bool = {
		var node: 	Option<Node<T>>
		var next:	Option<Node<T>>
		var prev:	Option<Node<T>>

        if(size <= 0)
            return false

		node = find(index)
		if(!node.IsDefined())
		    return false

        prev = node.Value().Prev()
        next = node.Value().Next()
        if(prev.IsDefined() && next.IsDefined()){
            // Node is in the middle of the list
            prev.Value().SetNext(next.Value())
            next.Value().SetPrev(prev.Value())
        }else if(prev.IsDefined() && ! next.IsDefined()){
            // Node is last element
            prev.Value().ClearNext()
            last = prev
        }else if(!prev.IsDefined() && next.IsDefined()){
            // Node is first element
            next.Value().ClearPrev()
            first = next
        }else{
            // Node is the only element
            Clear()
        }
        size--
		return true
	}

	Def IndexOf(value: T): Int = {
		var i: 	   Int
		var it:	   LinkedListIterator<T> = Iterator()

		while(it.HasNext()){
			if(it.Next() == value)
				return i
			i++
		}
		return -1
	}

	Def LastIndexOf(value: T): Int = {
		var index: Int = -1
		var i: 	   Int
		var it:	   LinkedListIterator<T> = Iterator()

		while(it.HasNext()){
			if(it.Next() == value)
				index = i
			i++
		}
		return index
	}

	Def Contains(value: T): Bool = {
		return IndexOf(value) != -1
	}

    Def toString(): String = {
        var it: LinkedListIterator<T>
        var s: 	String
        
        if(size == 0)
        	return "[]"

        it = Iterator()
        s = "[ "
        while(it.HasNext()){
            s = s + it.Next().toString()
            if(it.HasNext()) s = s + ", "
        }
        s = s + " ]"
        return s
    }

	Def Size(): Int = {
		return size
	}

	Def first(): Option<Node<T>> = {
		return first
	}

	Def last(): Option<Node<T>> = {
		return last
	}

	def find(index: Int): Option<Node<T>> = {
		var tmp: 	Option<Node<T>>
		var i: 		Int

		if(!indexInRange(index))
			return new Option<Node<T>>()
		if(index == 0)
			return first
		if(index == size - 1)
			return last

		if(index < (size / 2) + 1){
			tmp = first
			i = 0
			while(i < index && tmp.IsDefined()){
				i++
				tmp = tmp.Value().Next()
			}
		}else{
			tmp = last
			i = size - 1
			while(i > index && tmp.IsDefined()){
				i--
				tmp = tmp.Value().Prev()
			}
		}

		return tmp
	}

	def indexInRange(index: Int): Bool = {
		return index >= 0 && index < size
	}
}

class Node<T> {
	Var Value: T
	var next: Option<Node<T>> = new Option<Node<T>>()
	var prev: Option<Node<T>> = new Option<Node<T>>()

	Def new(v: T) = {
		Value = v
	}

	Def Next(): Option<Node<T>> = {
		return next
	}

	Def Prev(): Option<Node<T>> = {
		return prev
	}

	Def ClearNext(): Unit = {
		next = new Option<Node<T>>()
	}

	Def ClearPrev(): Unit = {
		prev = new Option<Node<T>>()
	}

	Def SetNext(n: Node<T>): Unit = {
		next = new Option<Node<T>>(n)
	}

	Def SetPrev(n: Node<T>): Unit = {
		prev = new Option<Node<T>>(n)
	}
}

class LinkedListIterator<T> {
	var current: Node<T>
	var hasNext: Bool

	Def new(list: LinkedList<T>) = {
		hasNext = list.NonEmpty()
		if(list.first().IsDefined())
			current = list.first().Value()
	}

	Def HasNext(): Bool = {
		return hasNext
	}

	Def Next(): T = {
		var res: T = current.Value

		hasNext = current.Next().IsDefined()
		if(hasNext)
			current = current.Next().Value()
		return res
	}
}