package kool.std

import <Option>

class LinkedList<T> {

	var first: Option<Node<T>> = new Option<Node<T>>()
	var last:  Option<Node<T>> = new Option<Node<T>>()

	var size: Int = 0

	Def new() = {}

	Def new(size: Int, value: T) = {
		var i: Int = 0
        for(i = 0; i < size; i++)
        	Push(value)
	}

	Def new(list: LinkedList<T>) = AddAll(list)

	Def [](index: Int): T = {
		checkBounds(index)
		return find(index).Value().Value
	}

	Def []=(index: Int, value: T): Unit = {
		checkBounds(index)
		find(index).Value().Value = value
	}

	Def ==(lhs: LinkedList<T>, rhs: LinkedList<T>): Bool = {
		var lhsIt:  LinkedListIterator<T>
		var rhsIt:  LinkedListIterator<T>

		if(lhs.size != rhs.size)
			return false

		lhsIt = lhs.Iterator()
		rhsIt = rhs.Iterator()
		while(lhsIt.HasNext()){
			if(lhsIt.Next() != rhsIt.Next())
				return false
		}

		return true
	}

	Def +(lhs: LinkedList<T>, rhs: T): LinkedList<T> = {
		lhs.Push(rhs)
		return lhs
	}

	Def +(lhs: LinkedList<T>, rhs: LinkedList<T>): LinkedList<T> = {
		lhs.AddAll(rhs)
		return lhs
	}

	Def -(lhs: LinkedList<T>, rhs: T): LinkedList<T> = {
		lhs.Remove(rhs)
		return lhs
	}

    Def NonEmpty(): Bool = return size != 0

	Def IsEmpty(): Bool = return size == 0

	Def Clear(): Unit = {
		first = new Option<Node<T>>()
        last = new Option<Node<T>>()
        size = 0
	}

	Def Iterator(): LinkedListIterator<T> =	return new LinkedListIterator<T>(this)

	Def Push(value: T): Unit = {
		var node: Node<T> = new Node<T>(value)

		if(!first.IsDefined()){
			first.Add(node)
			last = first
		} else {
			node.SetPrev(last.Value())
			last.Value().SetNext(node)
			last = last.Value().Next()
		}
		size++
	}

	Def Pop(): T = {
		var res: T
		if(size <= 0)
		    error("Cannot pop empty stack!")

		res = last.Value().Value
		RemoveIndex(size - 1)
		return res
	}

	Def Add(value: T): Unit = Add(0, value)
	Def Add(index: Int, value: T): Unit = {
		var node: Option<Node<T>>
		var next: Option<Node<T>>
		var prev: Option<Node<T>>
		var op:	  Option<Node<T>>
		var elem: Node<T>
		var res:  Bool

		if(index != size)
			checkBounds(index)

        elem = new Node<T>(value)
        if(index == size){
            Push(value)
        }else if(index == 0){
            first.Value().SetPrev(elem)
            elem.SetNext(first.Value())
            op = new Option<Node<T>>(elem)
            first = op
        }else{
            node = find(index)
            prev = node.Value().Prev()
            next = node.Value().Next()

            prev.Value().SetNext(elem)
            elem.SetPrev(prev.Value())

            elem.SetNext(node.Value())
            node.Value().SetPrev(elem)
        }
        size++
	}

    Def AddAll(list: LinkedList<T>): Unit = {
    	var it: LinkedListIterator<T> = list.Iterator()
    	while(it.HasNext())
    		Push(it.Next())
    }

	Def AddAll(index: Int, list: LinkedList<T>): Unit = {
		var it: LinkedListIterator<T> = list.Iterator()

		checkBounds(index)

		while(it.HasNext())
			Add(index, it.Next())
	}

	Def Remove(value: T): Bool = {
		var index: Int = IndexOf(value)

		if(index == -1)
			return false

		RemoveIndex(index)
		return true
	}

	Def RemoveIndex(index: Int): Unit = {
		var node: 	Option<Node<T>>
		var next:	Option<Node<T>>
		var prev:	Option<Node<T>>

		checkBounds(index)

		node = find(index)
        prev = node.Value().Prev()
        next = node.Value().Next()
        if(prev.IsDefined() && next.IsDefined()) {
            // Node is in the middle of the list
            prev.Value().SetNext(next.Value())
            next.Value().SetPrev(prev.Value())
        } else if(prev.IsDefined() && ! next.IsDefined()) {
            // Node is last element
            prev.Value().ClearNext()
            last = prev
        } else if(!prev.IsDefined() && next.IsDefined()) {
            // Node is first element
            next.Value().ClearPrev()
            first = next
        } else {
            // Node is the only element
            Clear()
        }
        size--
	}

	Def IndexOf(value: T): Int = {
		var i: 	   Int
		var it:	   LinkedListIterator<T> = Iterator()

		while(it.HasNext()){
			if(it.Next() == value)
				return i
			i++
		}
		return -1
	}

	Def LastIndexOf(value: T): Int = {
		var index: Int = -1
		var i: 	   Int
		var it:	   LinkedListIterator<T> = Iterator()

		while(it.HasNext()){
			if(it.Next() == value)
				index = i
			i++
		}
		return index
	}

	Def Contains(value: T): Bool = return IndexOf(value) != -1

    Def toString(): String = {
        var it: LinkedListIterator<T>
        var s: 	String
        
        if(size == 0)
        	return "[]"

        it = Iterator()
        s = "[ "
        while(it.HasNext()){
            s = s + it.Next().toString()
            if(it.HasNext()) s = s + ", "
        }
        s = s + " ]"
        return s
    }

	Def Size(): Int = return size

	Def first(): Option<Node<T>> = return first

	Def last(): Option<Node<T>> = return last

	def find(index: Int): Option<Node<T>> = {
		var tmp: 	Option<Node<T>>
		var i: 		Int

		if(index == 0)			 return first
		if(index == size - 1)	 return last

		if(index < (size / 2) + 1){
			tmp = first
			i = 0
			while(i < index && tmp.IsDefined()){
				i++
				tmp = tmp.Value().Next()
			}
		} else {
			tmp = last
			i = size - 1
			while(i > index && tmp.IsDefined()){
				i--
				tmp = tmp.Value().Prev()
			}
		}

		return tmp
	}

	def checkBounds(index: Int): Bool =
		if(index < 0 || index >= size)
			outOfBoundsError(index)

	def outOfBoundsError(index: Int): Unit = error("Index out of bounds: " + index + " (size: " + size + ")")
}

class Node<T> {
	Var Value: T
	var next: Option<Node<T>> = new Option<Node<T>>()
	var prev: Option<Node<T>> = new Option<Node<T>>()

	Def new(v: T) = Value = v

	Def Next(): Option<Node<T>> = return next

	Def Prev(): Option<Node<T>> = return prev

	Def ClearNext(): Unit = next = new Option<Node<T>>()

	Def ClearPrev(): Unit = prev = new Option<Node<T>>()

	Def SetNext(n: Node<T>): Unit = next = new Option<Node<T>>(n)

	Def SetPrev(n: Node<T>): Unit = prev = new Option<Node<T>>(n)
}

class LinkedListIterator<T> {
	var current: Node<T>
	var hasNext: Bool

	Def new(list: LinkedList<T>) = {
		hasNext = list.NonEmpty()
		if(list.first().IsDefined())
			current = list.first().Value()
	}

	Def HasNext(): Bool = return hasNext

	Def Next(): T = {
		var res: T = current.Value

		hasNext = current.Next().IsDefined()
		if(hasNext)
			current = current.Next().Value()
		return res
	}
}