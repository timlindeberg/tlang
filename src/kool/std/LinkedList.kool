package kool.std

import <Option>

class LinkedList<T> {

	var first = new Option<Node<T>>()
	var last  = new Option<Node<T>>()

	var size = 0

	Def new() = {}

	Def new(size: Int, value: T) =
        for(var i = 0; i < size; i++)
        	Push(value)

	Def new(list: LinkedList<T>) = AddAll(list)

	Def [](index: Int) = {
		checkBounds(index)
		return find(index).Value().Value
	}

	Def []=(index: Int, value: T) = {
		checkBounds(index)
		find(index).Value().Value = value
	}

	Def ==(lhs: LinkedList<T>, rhs: LinkedList<T>) = {
		if(lhs.size != rhs.size)
			return false

		var lhsIt = lhs.Iterator()
		var rhsIt = rhs.Iterator()
		while(lhsIt.HasNext()){
			if(lhsIt.Next() != rhsIt.Next())
				return false
		}

		return true
	}

	Def !=(lhs: LinkedList<T>, rhs: LinkedList<T>) = !(lhs == rhs)


	Def +(lhs: LinkedList<T>, rhs: T) = {
		lhs.Push(rhs)
		return lhs
	}

	Def +(lhs: LinkedList<T>, rhs: LinkedList<T>) = {
		lhs.AddAll(rhs)
		return lhs
	}

	Def -(lhs: LinkedList<T>, rhs: T) = {
		lhs.Remove(rhs)
		return lhs
	}

	Def #(list: LinkedList<T>) = {
		var res = 0
		var it = list.Iterator()
		while(it.HasNext())
			res = 31 * res + #it.Next()
		return res
	}

    Def NonEmpty() = return size != 0

	Def IsEmpty() = return size == 0

	Def Clear() = {
		first = new Option<Node<T>>()
        last = new Option<Node<T>>()
        size = 0
	}

	Def Iterator() = return new LinkedListIterator<T>(this)

	Def Push(value: T) = {
		var node = new Node<T>(value)

		if(!first.IsDefined()){
			first.Add(node)
			last = first
		} else {
			node.SetPrev(last.Value())
			last.Value().SetNext(node)
			last = last.Value().Next()
		}
		size++
	}

	Def Pop() = {
		if(size <= 0)
		    error("Cannot pop empty stack!")

		var res = last.Value().Value
		RemoveIndex(size - 1)
		return res
	}

	Def Add(value: T) = Add(0, value)
	Def Add(index: Int, value: T) = {
		if(index != size)
			checkBounds(index)

        var elem = new Node<T>(value)
        if(index == size){
            Push(value)
        }else if(index == 0){
            first.Value().SetPrev(elem)
            elem.SetNext(first.Value())
            first = new Option<Node<T>>(elem)
        }else{
            var node = find(index)
            var prev = node.Value().Prev()
            var next = node.Value().Next()

            prev.Value().SetNext(elem)
            elem.SetPrev(prev.Value())

            elem.SetNext(node.Value())
            node.Value().SetPrev(elem)
        }
        size++
	}

    Def AddAll(list: LinkedList<T>) = {
    	var it =  list.Iterator()
    	while(it.HasNext())
    		Push(it.Next())
    }

	Def AddAll(index: Int, list: LinkedList<T>) = {
		checkBounds(index)

		var it =  list.Iterator()
		while(it.HasNext())
			Add(index, it.Next())
	}

	Def Remove(value =  {
		var index: Int = IndexOf(value)

		if(index == -1)
			return false

		RemoveIndex(index)
		return true
	}

	Def RemoveIndex(index =  {
		checkBounds(index)

		var node =  find(index)
        var prev =  node.Value().Prev()
        var next =  node.Value().Next()
        if(prev.IsDefined() && next.IsDefined()) {
            // Node is in the middle of the list
            prev.Value().SetNext(next.Value())
            next.Value().SetPrev(prev.Value())
        } else if(prev.IsDefined() && ! next.IsDefined()) {
            // Node is last element
            prev.Value().ClearNext()
            last = prev
        } else if(!prev.IsDefined() && next.IsDefined()) {
            // Node is first element
            next.Value().ClearPrev()
            first = next
        } else {
            // Node is the only element
            Clear()
        }
        size--
	}

	Def IndexOf(value: T) = {
		var i: 	   Int
		var it:	   LinkedListIterator<T> = Iterator()
		while(it.HasNext()){
			if(it.Next() == value)
				return i
			i++
		}
		return -1
	}

	Def LastIndexOf(value: T) = {
		var index =  -1
		var i: 	   Int
		var it:	   LinkedListIterator<T> = Iterator()

		while(it.HasNext()){
			if(it.Next() == value)
				index = i
			i++
		}
		return index
	}

	Def Contains(value: T) = return IndexOf(value) != -1

	Def MakeString(delimiter: String) = {
		var it = Iterator()
		var s = ""
		while(it.HasNext()){
			s += it.Next()
			if(it.HasNext())
				s += delimiter
		}
		return s
	}

    Def toString() = return "[" + MakeString(", ") + "]"

	Def Size() = return size

	Def first() = return first

	Def last() = return last

	def find(index: Int) = {
		if(index == 0)			 return first
		if(index == size - 1)	 return last

		if(index < (size / 2) + 1){
			var tmp =  first
			for(var i =  0 ; i < index && tmp.IsDefined(); i++)
				tmp = tmp.Value().Next()
		} else {
			var tmp =  last
			for(var i =  size - 1 ; i > index && tmp.IsDefined(); i++)
				tmp = tmp.Value().Prev()
		}

		return tmp
	}

	def checkBounds(index: Int) =
		if(index < 0 || index >= size)
			outOfBoundsError(index)

	def outOfBoundsError(index: Int) = error("Index out of bounds: " + index + " (size: " + size + ")")
}

class Node<T> {
	Var Value: T
	var next: Option<Node<T>> = new Option<Node<T>>()
	var prev: Option<Node<T>> = new Option<Node<T>>()

	Def new(v: T) = Value = v

	Def Next() = return next

	Def Prev() = return prev

	Def ClearNext() = next = new Option<Node<T>>()

	Def ClearPrev() = prev = new Option<Node<T>>()

	Def SetNext(n: Node<T>) = next = new Option<Node<T>>(n)

	Def SetPrev(n: Node<T>) = prev = new Option<Node<T>>(n)
}

class LinkedListIterator<T> {
	var current: Node<T>
	var hasNext: Bool

	Def new(list: LinkedList<T>) = {
		hasNext = list.NonEmpty()
		if(list.first().IsDefined())
			current = list.first().Value()
	}

	Def HasNext() = return hasNext

	Def Next() = {
		var res =  current.Value

		hasNext = current.Next().IsDefined()
		if(hasNext)
			current = current.Next().Value()
		return res
	}
}