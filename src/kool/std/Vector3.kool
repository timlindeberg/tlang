package kool.std

import java.lang.Math

class Vector3<T> {

    Var X: T
    Var Y: T
    Var Z: T

    //------------------------------------------------------
    // Constructors
    //------------------------------------------------------

    Def new(x: T, y: T, z: T) = {
        X = x
        Y = y
        Z = z
    }

    Def implicit new(arr: T[]) = {
        if(arr.length != 3)
            error("Cannot initialize Vector3 with array of dimension" + arr.length)

        X = arr[0]
        Y = arr[1]
        Z = arr[2]
    }

    Def new(value: T) = (X = Y = Z = value)

    //------------------------------------------------------
    // Operators
    //------------------------------------------------------

    Def +(lhs: Vector3<T>, rhs: Vector3<T>) = new Vector3<T>(lhs.X + rhs.X, lhs.Y + rhs.Y, lhs.Z + rhs.Z)

    Def -(lhs: Vector3<T>, rhs: Vector3<T>) = new Vector3<T>(lhs.X - rhs.X, lhs.Y - rhs.Y, lhs.Z - rhs.Z)

    Def *(lhs: Vector3<T>, rhs: Vector3<T>) = new Vector3<T>(lhs.X * rhs.X, lhs.Y * rhs.Y, lhs.Z * rhs.Z)

    Def *(lhs: T, rhs: Vector3<T>) = new Vector3<T>(lhs * rhs.X, lhs * rhs.Y, lhs * rhs.Z)

    Def *(lhs: Vector3<T>, rhs: T) = rhs * lhs

    Def /(lhs: Vector3<T>, rhs: Vector3<T>) = new Vector3<T>(lhs.X / rhs.X, lhs.Y / rhs.Y, lhs.Z / rhs.Z)

    Def /(lhs: Vector3<T>, rhs: T) = new Vector3<T>(lhs.X / rhs, lhs.Y / rhs, lhs.Z / rhs)

    Def ==(lhs: Vector3<T>, rhs: Vector3<T>) = lhs.X == rhs.X && lhs.Y == rhs.Y && lhs.Z == rhs.Z

    Def !=(lhs: Vector3<T>, rhs: Vector3<T>) = !(lhs == rhs)

    Def ^(lhs: Vector3<T>, rhs: Vector3<T>) = lhs.Cross(rhs)

    Def |(lhs: Vector3<T>, rhs: Vector3<T>) = lhs.Dot(rhs)

    Def -(vec: Vector3<T>) = new Vector3<T>(-vec.X, -vec.Y, -vec.Z)

    Def #(vec: Vector3<T>) = 31 * #vec.X ^ 31 * #vec.Y ^ 31 * #vec.Z

    //------------------------------------------------------
    // Public static methods
    //------------------------------------------------------

    Def static Angle(lhs: Vector3<T>, rhs: Vector3<T>) = Math.acos(Dot(lhs, rhs) / (lhs.Magnitude() * rhs.Magnitude()))

    Def static Distance(lhs: Vector3<T>, rhs: Vector3<T>) = (lhs - rhs).Magnitude()

    Def static Dot(lhs: Vector3<T>, rhs: Vector3<T>) = lhs.X * rhs.X + lhs.Y * rhs.Y + lhs.Z * rhs.Z

    Def static Cross(lhs: Vector3<T>, rhs: Vector3<T>) = new Vector3<T>(lhs.Y * rhs.Z - lhs.Z * rhs.Y,
                                                                        lhs.Z * rhs.X - lhs.X * rhs.Z,
                                                                        lhs.X * rhs.Y - lhs.Y * rhs.X)

    //------------------------------------------------------
    // Public methods
    //------------------------------------------------------

    Def Magnitude() = Math.sqrt(X * X + Y * Y + Z * Z)

    Def Normalized() = this / Magnitude()

    Def Angle(other: Vector3<T>) = Angle(this, other)

    Def Distance(other: Vector3<T>) = Distance(this, other)

    Def Dot(other: Vector3<T>) = Dot(this, other)

    Def Cross(other: Vector3<T>) = Cross(this, other)

    Def toString() = "(" + X + ", " + Y + ", " + Z + ")"

}