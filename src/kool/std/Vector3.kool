package kool.std

import java.lang.Math

class Vector3<T> {

    Var X: T
    Var Y: T
    Var Z: T

    //------------------------------------------------------
    // Constructors
    //------------------------------------------------------

    Def new(x: T, y: T, z: T) = {
        X = x
        Y = y
        Z = z
    }

    Def new(value: T) = X = Y = Z = value

    //------------------------------------------------------
    // Operators
    //------------------------------------------------------

    Def +(lhs: Vector3<T>, rhs: Vector3<T>): Vector3<T> =
        return new Vector3<T>(lhs.X + rhs.X, lhs.Y + rhs.Y, lhs.Z + rhs.Z)

    Def -(lhs: Vector3<T>, rhs: Vector3<T>): Vector3<T> =
        return new Vector3<T>(lhs.X - rhs.X, lhs.Y - rhs.Y, lhs.Z - rhs.Z)

    Def *(lhs: Vector3<T>, rhs: Vector3<T>): Vector3<T> =
        return new Vector3<T>(lhs.X * rhs.X, lhs.Y * rhs.Y, lhs.Z * rhs.Z)

    Def *(lhs: T, rhs: Vector3<T>): Vector3<T> =
        return new Vector3<T>(lhs * rhs.X, lhs * rhs.Y, lhs * rhs.Z)

    Def *(lhs: Vector3<T>, rhs: T): Vector3<T> =
        return rhs * lhs

    Def /(lhs: Vector3<T>, rhs: Vector3<T>): Vector3<T> =
        return new Vector3<T>(lhs.X / rhs.X, lhs.Y / rhs.Y, lhs.Z / rhs.Z)

    Def /(lhs: Vector3<T>, rhs: T): Vector3<T> =
        return new Vector3<T>(lhs.X / rhs, lhs.Y / rhs, lhs.Z / rhs)

    Def ==(lhs: Vector3<T>, rhs: Vector3<T>): Bool =
        return lhs.X == rhs.X && lhs.Y == rhs.Y && lhs.Z == rhs.Z

    Def !=(lhs: Vector3<T>, rhs: Vector3<T>): Bool =
        return !(lhs == rhs)

    Def ^(lhs: Vector3<T>, rhs: Vector3<T>): Vector3<T> =
        return lhs.Cross(rhs)

    Def |(lhs: Vector3<T>, rhs: Vector3<T>): T =
        return lhs.Dot(rhs)

    //------------------------------------------------------
    // Public static methods
    //------------------------------------------------------

    Def static Angle(lhs: Vector3<T>, rhs: Vector3<T>): Double =
        return Math.acos(Dot(lhs, rhs) / (lhs.Magnitude() * rhs.Magnitude()))

    Def static Distance(lhs: Vector3<T>, rhs: Vector3<T>): Double =
        return (lhs - rhs).Magnitude()

    Def static Dot(lhs: Vector3<T>, rhs: Vector3<T>): T =
        return lhs.X * rhs.X + lhs.Y * rhs.Y + lhs.Z * rhs.Z

    Def static Cross(lhs: Vector3<T>, rhs: Vector3<T>): Vector3<T> =
        return new Vector3<T>(lhs.Y * rhs.Z - lhs.Z * rhs.Y,
                              lhs.Z * rhs.X - lhs.X * rhs.Z,
                              lhs.X * rhs.Y - lhs.Y * rhs.X)

    //------------------------------------------------------
    // Public methods
    //------------------------------------------------------

    Def Magnitude(): Double = return Math.sqrt(X * X + Y * Y + Z * Z)

    Def Normalized(): Vector3<T> = return this / Magnitude()

    Def Angle(other: Vector3<T>): Double = return Angle(this, other)

    Def Distance(other: Vector3<T>): Double = return Distance(this, other)

    Def Dot(other: Vector3<T>): T = return Dot(this, other)

    Def Cross(other: Vector3<T>): Vector3<T> = return Cross(this, other)

    Def toString(): String = return "(" + X + ", " + Y + ", " + Z + ")"

}