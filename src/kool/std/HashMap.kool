package kool.std

import <Option>

class HashMap<K, V> {

	var static DefualtInitialCapacity = 16
	var static DefaultLoadFactor = 0.75

	var entries: Option<Entry<K, V>>[]
	var size: Int
	var loadFactor: Double
	var capacity: Int

	Def new() =                                         init(DefualtInitialCapacity, DefaultLoadFactor)
	Def new(initialCapacity: Int) =                     init(initialCapacity, DefaultLoadFactor)
	Def new(initialCapacity: Int, loadFactor: Double) = init(initialCapacity, loadFactor)
	Def new(map: HashMap<K, V>) = {
		init(map.capacity, map.loadFactor)
		AddAll(map)
	}

	Def implicit new(entries: Entry<K, V>[]) = {
		init(entries.length, DefaultLoadFactor)
		for(var i = 0; i < entries.length; i++){
			var e = entries[i]
			this[e.Key] = e.Value
		}
	}

	Def []=(key: K, value: V) = {
		if(size >= loadFactor * capacity)
			resize()

		var hash = #key
		var newEntry = new Entry<K, V>(key, value, hash)

		if(addTo(entries, index(hash, capacity), newEntry))
			size++
	}

	Def [](key: K) = {
		var res = Get(key)
		if(!res.IsDefined())
			errorEntryNotFound(key)

		res.Value()
	}

	Def +(lhs: HashMap<K, V>, rhs: HashMap<K, V>)  = {
		var newMap = new HashMap<K, V>(lhs.capacity + rhs.capacity, lhs.loadFactor)
		newMap.AddAll(lhs)
		newMap.AddAll(rhs)
		newMap
	}

	Def -(map: HashMap<K, V>, key: K) = {
		var newMap = new HashMap<K, V>(map.capacity, map.loadFactor)
		newMap.AddAll(map)
		newMap.Remove(key)
		newMap
	}

	Def ==(lhs: HashMap<K, V>, rhs: HashMap<K, V>) = {
		if(lhs.Size() != rhs.Size())
			return false

		var lhsIt = lhs.EntryIterator()
		while(lhsIt.HasNext()){
			var lhsEntry = lhsIt.Next()
			var maybeValue = rhs.Get(lhsEntry.Key)
			if(!maybeValue.IsDefined())
				return false

			if(maybeValue.Value() != lhsEntry.Value)
				return false
		}
		true
	}

	Def !=(lhs: HashMap<K, V>, rhs: HashMap<K, V>) = !(lhs == rhs)

	Def #(map: HashMap<K, V>) = {
		var res = 0
		var it = map.EntryIterator()
		while(it.HasNext()){
			var e = it.Next()
			res += #e.Key ^ #e.Value
		}
		res
	}

	Def AddAll(other: HashMap<K, V>) = {
		var it = other.EntryIterator()
		while(it.HasNext()){
			var e = it.Next()
			this[e.Key] = e.Value
		}
	}

	Def Get(key: K) = {
		var maybeEntry = entries[index(#key, capacity)]
		if(!maybeEntry.IsDefined())
			return new Option<V>()

		var it = maybeEntry.Value().Iterator()
		while(it.HasNext()){
			var e = it.Next()
			if(e.Key == key)
				return new Option<V>(e.Value)
		}
		new Option<V>()
	}

	Def Remove(key: K) = {
		var index = index(#key, capacity)
		var maybeEntry = entries[index]

		if(!maybeEntry.IsDefined())
			return

		var it = maybeEntry.Value().Iterator()
		var entry: Entry<K, V>
		var previous = new Option<Entry<K, V>>()
		while(it.HasNext()){
			entry = it.Next()
			if(entry.Key == key){
				if(!previous.IsDefined())
					entries[index] = new Option<Entry<K, V>>()
				else if(it.HasNext())
					previous.Value().Next = new Option<Entry<K, V>>(it.Next())
				else
					previous.Value().Next = new Option<Entry<K, V>>()

				size--
				return
			}
			previous = new Option<Entry<K, V>>(entry)
		}
	}

	Def Clear() = {
		entries = getNewDataContainer(capacity)
		size = 0
	}

	Def Size() = size
	Def Capacity() = capacity

	Def IsEmpty() = size == 0
	Def NonEmpty() = size != 0

	Def ContainsKey(key: K) = Get(key).IsDefined()
	Def ContainsValue(value: V) = {
		var it = EntryIterator()
		while(it.HasNext())
			if(it.Next().Value == value)
				return true

		false
	}

	Def EntryIterator() = new EntryIterator<K, V>(entries, this)
	Def KeyIterator()   = new KeyIterator<K, V>(entries, this)
	Def ValueIterator() = new ValueIterator<K, V>(entries, this)

	Def toString() = {
		var s = ""
		var it = EntryIterator()
		while(it.HasNext())
			s += it.Next() + "\n"
	    s
	}

	def init(initialCapacity: Int, loadFactor: Double) = {
		capacity = (initialCapacity % 2 == 0) ? initialCapacity : closestPowerOfTwo(initialCapacity)
		this.loadFactor = loadFactor
		Clear()
	}

	def getNewDataContainer(capacity: Int) = {
		var data = new Option<Entry<K, V>>[capacity]
		for(var i = 0; i < capacity; i++)
			data[i] = new Option<Entry<K, V>>()
		data
	}

	def addTo(data: Option<Entry<K, V>>[], index: Int, newEntry: Entry<K, V>) = {
		var maybeEntry = data[index]

		if(!maybeEntry.IsDefined()){
			maybeEntry.Add(newEntry)
			return true
		}

		var it = maybeEntry.Value().Iterator()
		var entry: Entry<K, V>
		while(it.HasNext()){
			entry = it.Next()
			if(entry.Key == newEntry.Key){
				entry.Value = newEntry.Value
				return false
			}
		}
		entry.Next = new Option<Entry<K, V>>(newEntry)
		true
	}

	def resize() = {
		var newCapacity = capacity << 1
		var newData = getNewDataContainer(newCapacity)

		for(var i: Int = 0; i < capacity; i++){
			if(entries[i].IsDefined()){
				var it = entries[i].Value().Iterator()
				while(it.HasNext()){
					var entry = it.Next()
					entry.Next = new Option<Entry<K, V>>()
					addTo(newData, index(entry.Hash, newCapacity), entry)
				}
			}
		}
		entries = newData
		capacity = newCapacity
	}

	def closestPowerOfTwo(value: Int) =
		for(var i = 2; ; i <<= 1)
			if(i >= value)
			   return i

	def index(hashCode: Int, capacity: Int) = improvedHash(hashCode) & capacity - 1

	def improvedHash(h: Int) = {
		h ^= (h >> 20) ^ (h >> 12)
        h ^ (h >> 7) ^ (h >> 4)
	}

	def errorEntryNotFound(key: K) = error("No such key: " + key)

}

class Entry<K, V> {

	Var Key: K
	Var Value: V
	Var Hash: Int
	Var Next: Option<Entry<K, V>>

	Def new(key: K, value: V) 			 = init(key, value, 0)
	Def new(key: K, value: V, hash: Int) = init(key, value, hash)

	Def ==(lhs: Entry<K, V>, rhs: Entry<K, V>) =
		lhs.Key == rhs.Key &&
	    lhs.Value == rhs.Value

	Def Iterator() = new EntryListIterator<K, V>(this)

	Def toString() = "(" + Key + " -> " + Value + ")"

	def init(key: K, value: V, hash: Int) = {
		Key = key
		Value = value
		Hash = hash
		Next = new Option<Entry<K, V>>()
	}

}

class EntryListIterator<K, V> {

	var hasNext: Bool
	var current: Entry<K, V>

	Def new(startEntry: Entry<K, V>) = {
		hasNext = true
		current = startEntry
	}

	Def HasNext() = hasNext

	Def Next() = {
		var res = current
		hasNext = current.Next.IsDefined()
		if(hasNext)
			current = current.Next.Value()
		res
	}
}

class KeyIterator<K, V> {

	var it: EntryIterator<K, V>

	Def new(entries: Option<Entry<K, V>>[], map: HashMap<K, V>) =
		it = new EntryIterator<K, V>(entries, map)

	Def HasNext() = it.HasNext()

	Def Next() = it.Next().Key

}

class ValueIterator<K, V> {

	var it: EntryIterator<K, V>

	Def new(entries: Option<Entry<K, V>>[], map: HashMap<K, V>) =
		it = new EntryIterator<K, V>(entries, map)

	Def HasNext() = it.HasNext()

	Def Next() = it.Next().Value

}

class EntryIterator<K, V> {

	var hasNext: Bool
	var currentEntry: Option<Entry<K, V>>
	var currentIndex: Int
	var entries: Option<Entry<K, V>>[]
	var map: HashMap<K, V>

	Def new(entries: Option<Entry<K, V>>[], map: HashMap<K, V>) = {
		this.map = map
		this.entries = entries
		hasNext = map.NonEmpty()
		currentEntry = nextDefinedEntry()
	}

	Def HasNext() = hasNext

	Def Next() = {
		var res = currentEntry.Value()
		currentEntry = nextEntry()
		hasNext = currentEntry.IsDefined()
		return res
	}

	def nextEntry() = {
		if(currentEntry.IsDefined() && currentEntry.Value().Next.IsDefined())
			return currentEntry.Value().Next

		nextDefinedEntry()
	}

	def nextDefinedEntry() = {
		for(; currentIndex < map.Capacity(); currentIndex++){
			if(entries[currentIndex].IsDefined()){
				var res = entries[currentIndex]
				currentIndex++
				return res
			}
		}

		new Option<Entry<K, V>>()
	}


}