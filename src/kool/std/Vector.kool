package kool.std

import <Option>

class Vector<T> {

	var static InitialCapacity: Int = 10
	var size: Int = 0
	var data: T[]

	Def new() = Clear()

	Def new(list: Vector<T>) = {
		Clear()
		AddAll(list)
	}

	Def new(initSize: Int, value: T) = {
		size = initSize
		data = new T[size]
		for(var i = 0; i < size; i++)
			data[i] = value
	}


	Def [](index: Int): T = {
		checkBounds(index)
		return data[index]
	}

	Def []=(index: Int, value: T): Unit = {
		checkBounds(index)
		data[index] = value
	}

	Def ==(lhs: Vector<T>, rhs: Vector<T>): Bool = {
		if(lhs.size != rhs.size)
			return false

		var lhsIt:  VectorIterator<T> = lhs.Iterator()
		var rhsIt:  VectorIterator<T> = rhs.Iterator()
		while(lhsIt.HasNext())
			if(lhsIt.Next() != rhsIt.Next())
				return false

		return true
	}

	Def !=(lhs: Vector<T>, rhs: Vector<T>): Bool = return !(lhs == rhs)

	Def +(lhs: Vector<T>, rhs: T): Vector<T> = {
		lhs.Push(rhs)
		return lhs
	}

	Def +(lhs: Vector<T>, rhs: Vector<T>): Vector<T> = {
		lhs.AddAll(rhs)
		return lhs
	}

	Def -(lhs: Vector<T>, rhs: T): Vector<T> = {
		lhs.Remove(rhs)
		return lhs
	}

	Def #(vector: Vector<T>): Int = {
		var res = 0
		for(var i = 0; i < vector.size; i++)
			res = 31 * res + #vector[i]

		return res
	}

    Def NonEmpty(): Bool = return size != 0

	Def IsEmpty(): Bool = return size == 0

	Def Clear(): Unit = {
		size = 0
		data = new T[InitialCapacity]
	}

	Def Iterator(): VectorIterator<T> =	return new VectorIterator<T>(this)

	Def Push(value: T): Unit = {
		if(size >= data.length)
			increaseStorage()

		data[size++] = value
	}

	Def Pop(): T = {
		if(size == 0)
			error("Cannot pop empty stack!")

		return data[--size]
	}

	Def Add(value: T): Unit = Add(0, value)
	Def Add(index: Int, value: T): Unit = {
		if(index != size)
			checkBounds(index)

		if(size >= data.length)
			increaseStorage()

		for(var i = size; i > index; i--)
			data[i] = data[i - 1]

		data[index] = value
		size++
	}

    Def AddAll(list: Vector<T>): Unit =	AddAll(size, list)
	Def AddAll(index: Int, list: Vector<T>): Unit = {
		if(index != size)
        	checkBounds(index)

		var newData = new T[size + list.size]

		for(var i = 0; i < index; i++)
			newData[i] = data[i]

		for(var i = 0; i < list.size; i++)
			newData[i + index] = list.data[i]

		for(var i = 0; i < size - index; i++ )
			newData[i + index + list.size] = data[index + i]

		data = newData
		size += list.size
	}

	Def RemoveIndex(index: Int): Unit = {
		checkBounds(index)

		for(var i = index; i < size; i++)
			data[i] = data[i + 1]

		size--
	}

	Def Remove(value: T): Bool = {
	    var index = IndexOf(value)

	    if(index == -1)
	        return false

	    RemoveIndex(index)
	    return true
	}

	Def IndexOf(value: T): Int = {
		for(var i = 0; i < size; i++){
			if(data[i] == value)
				return i
		}
		return -1
	}

	Def LastIndexOf(value: T): Int = {
		var res = -1
		for(var i = 0; i < size; i++){
			if(data[i] == value){
				res = -1
			}
		}
		return res
	}

	Def Contains(value: T): Bool = return IndexOf(value) != -1

	Def Size(): Int = return size

	Def First(): T = return this[0]
	Def Last(): T = return this[size - 1]

    Def toString(): String = {
		if(size == 0)
			return "[]"

		var s = "[ "
		for(var i = 0; i < size; i++){
			s += this[i]
			if(i != size  - 1)
				s += ", "
		}
		return s + " ]"
    }

	def increaseStorage(): Unit = {
		var newData = new T[(data.length * 3) / 2 + 1]

		for(var i = 0; i < data.length; i++)
			newData[i] = data[i]
		data = newData
	}

	def checkBounds(index: Int): Bool =
		if(index < 0 || index >= size)
			outOfBoundsError(index)

    def outOfBoundsError(index: Int): Unit = error("Index out of bounds: " + index + " (size: " + size + ")")

}

class VectorIterator<T> {
	var current: Int
	var hasNext: Bool
	var vector: Vector<T>

	Def new(list: Vector<T>) = {
		current = 0
		hasNext = list.NonEmpty()
		vector = list
	}

	Def HasNext(): Bool = return hasNext

	Def Next(): T = {
		hasNext = current < vector.Size() - 1
		return vector[current++]
	}
}
