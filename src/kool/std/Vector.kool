package kool.std

import <Option>

class Vector<T> {

	var static InitialCapacity = 10
	var size = 0
	var data: T[]

	Def new() = Clear()

	Def new(list: Vector<T>) = {
		Clear()
		AddAll(list)
	}

	Def implicit new(array: T[]) = {
		Clear()
		for(var i = 0; i < array.Size(); i++)
			Push(array[i])
	}

	Def new(initSize: Int, value: T) = {
		size = initSize
		data = new T[size]
		for(var i = 0; i < size; i++)
			data[i] = value
	}


	Def [](index: Int) = {
		checkBounds(index)
		data[index]
	}

	Def []=(index: Int, value: T) = {
		checkBounds(index)
		data[index] = value
	}

	Def ==(lhs: Vector<T>, rhs: Vector<T>) = {
		if(lhs.size != rhs.size)
			return false

		var lhsIt = lhs.Iterator()
		var rhsIt = rhs.Iterator()
		while(lhsIt.HasNext())
			if(lhsIt.Next() != rhsIt.Next())
				return false

		true
	}

	Def !=(lhs: Vector<T>, rhs: Vector<T>) = !(lhs == rhs)

	Def +(lhs: Vector<T>, rhs: T) = {
		lhs.Push(rhs)
		lhs
	}

	Def +(lhs: Vector<T>, rhs: Vector<T>) = {
		lhs.AddAll(rhs)
		lhs
	}

	Def -(lhs: Vector<T>, rhs: T) = {
		lhs.Remove(rhs)
		lhs
	}

	Def #(vector: Vector<T>) = {
		var res = 0
		for(var i = 0; i < vector.size; i++)
			res = 31 * res + #vector[i]

		res
	}

    Def NonEmpty() = size != 0

	Def IsEmpty() = size == 0

	Def Clear() = {
		size = 0
		data = new T[InitialCapacity]
	}

	Def Iterator() = new VectorIterator<T>(this)

	Def Push(value: T) = {
		if(size >= data.Size())
			increaseStorage()

		data[size++] = value
	}

	Def Pop() = {
		if(size == 0)
			error("Cannot pop empty stack!")

		data[--size]
	}

	Def Add(value: T) = Add(0, value)
	Def Add(index: Int, value: T) = {
		if(index != size)
			checkBounds(index)

		if(size >= data.Size())
			increaseStorage()

		for(var i = size; i > index; i--)
			data[i] = data[i - 1]

		data[index] = value
		size++
	}

    Def AddAll(list: Vector<T>) = AddAll(size, list)
	Def AddAll(index: Int, list: Vector<T>) = {
		if(index != size)
        	checkBounds(index)

		var newData = new T[size + list.size]

		for(var i = 0; i < index; i++)
			newData[i] = data[i]

		for(var i = 0; i < list.size; i++)
			newData[i + index] = list.data[i]

		for(var i = 0; i < size - index; i++ )
			newData[i + index + list.size] = data[index + i]

		data = newData
		size += list.size
	}

	Def RemoveIndex(index: Int) = {
		checkBounds(index)

		for(var i = index; i < size; i++)
			data[i] = data[i + 1]

		size--
	}

	Def Remove(value: T) = {
	    var index = IndexOf(value)

	    if(index == -1)
	        return false

	    RemoveIndex(index)
	    true
	}

	Def IndexOf(value: T) = {
		for(var i = 0; i < size; i++)
			if(data[i] == value)
				return i
		-1
	}

	Def LastIndexOf(value: T) = {
		var res = -1
		for(var i = 0; i < size; i++)
			if(data[i] == value)
				res = -1
		res
	}

	Def MakeString(delimiter: String) = {
		var s = ""
		for(var i = 0; i < size; i++){
			s += this[i]
			if(i != size  - 1)
				s += delimiter
		}
		s
	}

	Def Contains(value: T) = IndexOf(value) != -1

	Def Size() = size

	Def First() = this[0]

	Def Last() = this[size - 1]

    Def toString() = "[" + MakeString(", ") + "]"

	def increaseStorage() = {
		var newData = new T[(data.Size() * 3) / 2 + 1]

		for(var i = 0; i < data.Size(); i++)
			newData[i] = data[i]
		data = newData
	}

	def checkBounds(index: Int) =
		if(index < 0 || index >= size)
			outOfBoundsError(index)

    def outOfBoundsError(index: Int) = error("Index out of bounds: " + index + " (size: " + size + ")")

}

class VectorIterator<T> {
	var current: Int
	var hasNext: Bool
	var vector: Vector<T>

	Def new(list: Vector<T>) = {
		current = 0
		hasNext = list.NonEmpty()
		vector = list
	}

	Def HasNext() = hasNext

	Def Next() = {
		hasNext = current < vector.Size() - 1
		vector[current++]
	}
}
