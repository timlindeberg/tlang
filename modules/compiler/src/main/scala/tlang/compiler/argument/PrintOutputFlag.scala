package tlang.compiler.argument

import tlang.compiler.Main
import tlang.compiler.code.Lowering
import tlang.formatting.Formatter
import tlang.options.OptionalArgumentFlag
import tlang.utils.Extensions._

case object PrintOutputFlag extends OptionalArgumentFlag[Set[String]] {
  override val name               = "printoutput"
  override val argDescription     = "phase"
  override val defaultArg: String = Lowering.phaseName

  private lazy val compilerPhases = Main.CompilerPhases.map(_.phaseName)

  override def isValidArg(compilerPhase: String): Boolean = compilerPhase.toLowerCase in compilerPhases


  override def description(formatter: Formatter): String = {
    import formatter.formatting._
    s"""
       |Prints the output after a given compiler phase.
       |If no argument is given the code is printed as it looks before the final code is generated (after the lowering phase).
       |Type --${ Magenta(CompilerHelpFlag.name) } ${ Magenta(name) } for more information.
      """.stripMargin.trim
  }


  override def extendedDescription(formatter: Formatter): String = {
    import formatter.formatting._

    val phases = formatter.list(Main.CompilerPhases.map(phase => Blue(phase.phaseName.capitalize)))
    s"""|The --${ Magenta(name) } flag prints the output after a given compiler phase.
        |This can be the tokens produced by the Lexer, a pretty printed and formatted AST or the
        |byte code generated by the Codegenerating phase.
        |The compiler phase are executed in the following order:
        |
        |$phases
        |
        |All these phase can be used as arguments.
        |If no argument is given the code is printed as it looks before the final code is generated (after the Lowering phase).
        |
        |Example: --${ Magenta(name) } ${ Blue("lexer") },${ Blue("desugaring") },${ Blue("codegeneration") }
        |""".stripMargin.trim
  }

  override def parseValue(args: Set[String]): Set[String] = args
}