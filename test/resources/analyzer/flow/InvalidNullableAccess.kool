var a: A? = new A()

a.Test()

a = null

a.Test() // res: F2001

a = GetA()
val b: A? = GetA()

GetA().Test() // res: F2002

if(A.staticA != null)
    A.staticA.Test()
A.staticA.Test() // res: F2000

var c: A? = new A()
if(c.nullable != null)
    c.nullable.Test()
c.nullable.Test() // res: F2000

if(c.nullable != null && c.nullable.bNullable != null)
    c.nullable.bNullable.Test()

if(c.nullable)
    c.nullable.Test()

if(c.nullable && c.nullable.bNullable)
    c.nullable.bNullable.Test()

// This should in theory not give an error
// but seems like a very strange case. It would only apply when
// we know the result of the ternary check is true or false
if(a == null ? true : false)
    a.Test() // res: F2000

// TODO: This should probably work
// if(c?.nullable?.bNullable != null)
//     c.nullable.bNullable.Test()

c.nullable.bNullable.Test() // res: F2000, F2000

a.Test() // res: F2000
println(a + b) // res: F2000, F2000

if(a != null && b != null)
    println(a + b)

if(a != null || b != null)
    println(a + b) // res: F2000, F2000

if(a != null)
    println(a + b) // res: F2000

if(b != null)
    println(a + b) // res: F2000

println(a) // Okay to print nullables
println(b) // Okay to print nullables

var arr: Int[]? = {1, 2, 3}

println(arr[0])

arr = GetArr()

if(arr != null)
    println(arr[0])
println(arr[0]) // res: F2000

if(arr != null){
    for(val i in arr)
        println(i)
}
for(val i in arr) // res: F2000
    println(i)


Def Test(b: A?) = {
    var a = b
    a.Test() // res: F2000
    if(a != null) {
        a.Test()
    } else {
        a.Test() // res: F2001
    }

    if(a.b) // res: F2000
        println()


    if(a != null && a.b)
        println()

    if(a == null)
        a.Test() // res: F2001
    else
        a.Test()

    if(a == new A() && a != new A() && a.b) // res: F2000
        a.Test() // res: F2000

    if(a == new A() && a != null && a.b)
        a.Test()

    while(a != null && a.b){
        a.Test()
        a = GetA()
        a.Test() // res: F2000
    }

    a = null
    while(a == null){
        a.Test() // res: F2001
        a = new A()
        a.Test()
    }

    for(var i = 0; a != null; i++) {
        a.Test()
        a = GetA()
        a.Test() // res: F2000
    }

    for(var i = 0; a == null; i++){
        a.Test() // res: F2001
        a = new A()
        a.Test()
    }

    if(a) a.Test()
    if(!a) a.Test() // res: F2001


    val c = GetA()

    if(a != null && c != null){
        a.Test()
        c.Test()
    }

    a = GetA()
    if(a != null && (a = GetA()) != null)
        a.Test()

    // Horrible edge case where the variable is reassigned
    // in the condition. Currently does not work.
    if(a != null && (a = GetA()) == new A())
        a.Test() // r//es: F2000

     // TODO Demorgans law:
     if(!(a == null || c == null)){
         a.Test()
         c.Test()
     }
    
     val i = 4
     val e = GetA()
     val f = GetA()
     if(!(a == null || c != null || (i == 5 && i != 4) || e == null || f == null)){
         // De morgans: a != null && c == null && !(i == 5 && i != 4) && e != null && f != null
         a.Test()
         c.Test()  // res: F2001
         e.Test()
         f.Test()
     }



}

Def Test2(b: A?) = {
    var a = b
    a.Test() // res: F2000
    if(a == null)
        return

    a.Test()

    a = GetA()

    if(a != null)
        return

    a.Test() // res: F2001

    if(a == null || b == null) {
        a.Test() // res: F2001
        b.Test() // res: F2000
    } else {
        a.Test() // res: F2001
        b.Test()
    }

    if(a == null || b == null)
        return


    a.Test() // res: F2001
    b.Test()

    a = GetA()

    if(a == null || a == b ){
        a.Test() // res: F2000
        b.Test()
    } else {
        a.Test()
        b.Test()
    }
}

Def Test3() = {
    val a = GetA()
    val b = GetA()
    val c = GetA()
    val d = GetA()
    val e = GetA()

    if(a) {
        a.Test()
        if(b){
            a.Test()
            b.Test()
            if(c){
                a.Test()
                b.Test()
                c.Test()
                if(e){
                    a.Test()
                    b.Test()
                    c.Test()
                    e.Test()
                }else{
                    a.Test()
                    b.Test()
                    c.Test()
                    e.Test() // res: F2001
                }
            }else{
                a.Test()
                b.Test()
                c.Test() // res: F2001
                e.Test() // res: F2000
            }
        } else {
            a.Test()
            b.Test() // res: F2001
            c.Test() // res: F2000
            e.Test() // res: F2000
        }
    } else {
        a.Test() // res: F2001
        b.Test() // res: F2000
        c.Test() // res: F2000
        e.Test() // res: F2000
    }
}


Def GetA(): A? = null
Def GetArr(): Int[]? = null

class A {

    Val static staticA: A? = null

    Val b = true
    Val nullable: B? = null


    Def Test() = println("Test")

    Def GetBool() = true

    Def +(a: A, b: A) = 5

}

class B {

    Val bNullable: C? = null
    Def Test() = println("Test")

}

class C {

    Def Test() = println("Test")

}